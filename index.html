<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Carrera IA F1</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 0; }
    #controls { margin: 20px; }
    canvas { background: #e0e0e0; display: block; margin: 0 auto; border: 2px solid #444; }
  </style>
</head>
<body>
  <h2>Carrera IA F1: Entrena tus coches</h2>
  <div id="controls">
    <label for="numCars">Número de IAs: </label>
    <input id="numCars" type="number" min="1" max="50" value="10" style="width: 60px;">
    <button onclick="entrenar()">Correr carrera</button>
    <button onclick="volverHacerCarrera()">Volver a hacer carrera</button>
  </div>
  <canvas id="game" width="800" height="400"></canvas>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const start = { x: 80, y: 200 };
    const goal = { x: 700, y: 320 };
    const numSteps = 90;

    const trackPath = [
      {x: 80, y: 200},
      {x: 200, y: 160},
      {x: 330, y: 120},
      {x: 460, y: 120},
      {x: 580, y: 200},
      {x: 640, y: 260},
      {x: 700, y: 320}
    ];
    const TRACK_WIDTH = 56;

    function drawTrack() {
      ctx.save();
      ctx.clearRect(0,0,canvas.width,canvas.height);

      ctx.strokeStyle = "#222";
      ctx.lineWidth = TRACK_WIDTH;
      ctx.beginPath();
      ctx.moveTo(trackPath[0].x, trackPath[0].y);
      for(let i=1; i<trackPath.length; i++){
        ctx.lineTo(trackPath[i].x, trackPath[i].y);
      }
      ctx.stroke();

      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 4;
      ctx.beginPath();
      for(let i=0; i<trackPath.length-1; i++){
        let dx = trackPath[i+1].x-trackPath[i].x;
        let dy = trackPath[i+1].y-trackPath[i].y;
        let len = Math.sqrt(dx*dx+dy*dy);
        let nx = -dy/len, ny = dx/len;
        ctx.moveTo(trackPath[i].x+nx*TRACK_WIDTH/2, trackPath[i].y+ny*TRACK_WIDTH/2);
        ctx.lineTo(trackPath[i+1].x+nx*TRACK_WIDTH/2, trackPath[i+1].y+ny*TRACK_WIDTH/2);
        ctx.moveTo(trackPath[i].x-nx*TRACK_WIDTH/2, trackPath[i].y-ny*TRACK_WIDTH/2);
        ctx.lineTo(trackPath[i+1].x-nx*TRACK_WIDTH/2, trackPath[i+1].y-ny*TRACK_WIDTH/2);
      }
      ctx.stroke();

      ctx.fillStyle = "green";
      ctx.fillRect(goal.x - 12, goal.y - 20, 24, 40);
      ctx.fillStyle = "#fff";
      ctx.fillRect(goal.x - 12, goal.y - 20, 24, 10);
      ctx.fillRect(goal.x - 12, goal.y + 10, 24, 10);

      ctx.restore();
    }

    function carOnTrack(x, y) {
      let minDist = Infinity;
      for(let i=0; i<trackPath.length-1; i++) {
        let ax = trackPath[i].x, ay = trackPath[i].y;
        let bx = trackPath[i+1].x, by = trackPath[i+1].y;
        let dx = bx-ax, dy = by-ay;
        let t = ((x-ax)*dx + (y-ay)*dy) / (dx*dx+dy*dy);
        t = Math.max(0, Math.min(1, t));
        let px = ax + t*dx;
        let py = ay + t*dy;
        let dist = Math.sqrt((x-px)**2 + (y-py)**2);
        if(dist<minDist) minDist = dist;
      }
      return minDist <= TRACK_WIDTH/2 - 5;
    }

    function drawCar(x, y, color, angle = 0) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.fillStyle = color;
      ctx.fillRect(-14, -7, 28, 14);
      ctx.fillStyle = "#222";
      ctx.fillRect(-6, -5, 12, 10);
      ctx.fillStyle = "#555";
      ctx.fillRect(-16, -3, 4, 6);
      ctx.fillRect(12, -3, 6, 6);
      ctx.restore();
    }

    function drawTrail(trail, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.globalAlpha = 0.4;
      ctx.lineWidth = 2;
      ctx.beginPath();
      if (trail.length > 0) {
        ctx.moveTo(trail[0].x, trail[0].y);
        for (let p of trail) ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function distancia(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function randomDirection() {
      const base = 12;
      return [
        { dx: base, dy: 0, da: 0 },
        { dx: base, dy: -4, da: -0.07 },
        { dx: base, dy: 4, da: 0.07 },
        { dx: base, dy: -8, da: -0.12 },
        { dx: base, dy: 8, da: 0.12 }
      ][Math.floor(Math.random() * 5)];
    }

    function mutarPath(path) {
      if (!path) return [];
      return path.map(dir => {
        if (Math.random() < 0.1) {
          return randomDirection();
        }
        return { ...dir };
      });
    }

    function generarCoches(n, heredanDe = null, bestPath = null) {
      let coches = [];
      for (let i = 0; i < n; i++) {
        let coche = {
          pos: { x: start.x, y: start.y },
          angle: 0,
          path: [],
          trail: [{ x: start.x, y: start.y }],
          color: `hsl(${(i * 360) / n}, 80%, 50%)`,
          terminado: false,
          score: 0,
          crashed: false
        };
        if (bestPath && (i === 0 || Math.random() < 0.3)) {
          coche.path = mutarPath(bestPath);
        } else if (heredanDe && heredanDe[i]) {
          coche.path = mutarPath(heredanDe[i].path);
        } else {
          coche.path = [];
        }
        coches.push(coche);
      }
      return coches;
    }

    function guardarMenteGlobal(path, distance) {
      localStorage.setItem("menteGlobalPath", JSON.stringify(path));
      localStorage.setItem("menteGlobalDist", distance);
    }
    function cargarMenteGlobal() {
      return {
        path: JSON.parse(localStorage.getItem("menteGlobalPath") || "null"),
        distance: Number(localStorage.getItem("menteGlobalDist") || "Infinity")
      };
    }
    function borrarMenteGlobal() {
      localStorage.removeItem("menteGlobalPath");
      localStorage.removeItem("menteGlobalDist");
    }

    let lastBestCars = null;

    // Correr carrera - SIEMPRE empieza desde cero pero usa el mejor récord global para comparación
    function entrenar() {
      // Creamos nuevos coches desde cero
      const n = parseInt(document.getElementById("numCars").value, 10);
      const generaciones = 1; // Solo una generación

      // Siempre cargamos el récord global al principio
      let mente = cargarMenteGlobal();
      let bestPath = mente.path;
      let bestDistance = mente.distance;
      lastBestCars = null;

      function ejecutarGeneracion(gen) {
        let coches = generarCoches(n, null, bestPath);
        let paso = 0;
        let carreraTerminada = false;

        function moverCoches() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawTrack();

          let algunoMoviendo = false;

          for (let car of coches) {
            if (!car.terminado && !car.crashed && paso < numSteps) {
              let dir;
              if (car.path[paso]) {
                dir = car.path[paso];
              } else if (bestPath && Math.random() < 0.7 && bestPath[paso]) {
                dir = bestPath[paso];
              } else {
                dir = randomDirection();
              }
              car.angle += dir.da;
              car.pos.x += dir.dx * Math.cos(car.angle);
              car.pos.y += dir.dx * Math.sin(car.angle) + dir.dy;
              car.path.push({ dx: dir.dx, dy: dir.dy, da: dir.da });
              car.trail.push({ x: car.pos.x, y: car.pos.y });

              if (!carOnTrack(car.pos.x, car.pos.y)) {
                car.crashed = true;
                car.terminado = true;
                car.score -= 100;
              }

              if (distancia(car.pos, goal) < 16) car.terminado = true;
              algunoMoviendo = true;
            }
            drawTrail(car.trail, car.color);
            drawCar(car.pos.x, car.pos.y, car.crashed ? "#f00" : car.color, car.angle);
          }

          paso++;
          if (algunoMoviendo && paso <= numSteps) {
            requestAnimationFrame(moverCoches);
          } else if (!carreraTerminada) {
            carreraTerminada = true;

            for (let car of coches) {
              let d = distancia(car.pos, goal);
              if (d < 16) {
                car.score = 1000 - car.trail.length;
              } else {
                car.score = Math.max(0, 500 - d);
              }
              if (car.crashed) car.score -= 100;
            }
            coches.sort((a, b) => b.score - a.score);

            for (let i = coches.length - 3; i < coches.length; i++) {
              if (i >= 0) coches[i].score -= 200;
            }

            // Si el mejor coche de esta carrera supera el récord global, lo actualizamos
            let mejorCoche = coches[0];
            let mejorDistanciaActual = distancia(mejorCoche.pos, goal);
            if (mejorCoche.score > 0 && (bestPath === null || mejorDistanciaActual < bestDistance)) {
              bestPath = mejorCoche.path;
              bestDistance = mejorDistanciaActual;
              guardarMenteGlobal(bestPath, bestDistance);
            }
            // Guardamos los mejores para referencia de la siguiente carrera
            lastBestCars = coches.slice(0, Math.max(3, Math.floor(coches.length / 4)));
          }
        }
        moverCoches();
      }
      ejecutarGeneracion(0);
    }

    // Volver a hacer carrera - SIEMPRE usa el récord global para los nuevos coches y solo lo actualiza si es superado
    function volverHacerCarrera() {
      const n = parseInt(document.getElementById("numCars").value, 10);

      if (!lastBestCars) {
        alert("Primero corre una carrera para que haya mejores coches de referencia.");
        return;
      }

      // SIEMPRE cargamos el récord global y lo usamos como referencia
      let mente = cargarMenteGlobal();
      let bestPath = mente.path;
      let bestDistance = mente.distance;

      function ejecutarGeneracion(gen) {
        let coches = generarCoches(n, lastBestCars, bestPath);
        let paso = 0;
        let carreraTerminada = false;

        function moverCoches() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawTrack();

          let algunoMoviendo = false;

          for (let car of coches) {
            if (!car.terminado && !car.crashed && paso < numSteps) {
              let dir;
              if (car.path[paso]) {
                dir = car.path[paso];
              } else if (bestPath && Math.random() < 0.5 && bestPath[paso]) {
                dir = bestPath[paso];
              } else {
                dir = randomDirection();
              }
              car.angle += dir.da;
              car.pos.x += dir.dx * Math.cos(car.angle);
              car.pos.y += dir.dx * Math.sin(car.angle) + dir.dy;
              car.trail.push({ x: car.pos.x, y: car.pos.y });

              if (!carOnTrack(car.pos.x, car.pos.y)) {
                car.crashed = true;
                car.terminado = true;
                car.score -= 100;
              }

              if (distancia(car.pos, goal) < 16) car.terminado = true;
              algunoMoviendo = true;
            }
            drawTrail(car.trail, car.color);
            drawCar(car.pos.x, car.pos.y, car.crashed ? "#f00" : car.color, car.angle);
          }

          paso++;
          if (algunoMoviendo && paso <= numSteps) {
            requestAnimationFrame(moverCoches);
          } else if (!carreraTerminada) {
            carreraTerminada = true;

            for (let car of coches) {
              let d = distancia(car.pos, goal);
              if (d < 16) {
                car.score = 1000 - car.trail.length;
              } else {
                car.score = Math.max(0, 500 - d);
              }
              if (car.crashed) car.score -= 100;
            }
            coches.sort((a, b) => b.score - a.score);

            for (let i = coches.length - 3; i < coches.length; i++) {
              if (i >= 0) coches[i].score -= 200;
            }

            // Si el mejor coche de esta carrera supera el récord global, lo actualizamos
            let mejorCoche = coches[0];
            let mejorDistanciaActual = distancia(mejorCoche.pos, goal);
            if (mejorCoche.score > 0 && (bestPath === null || mejorDistanciaActual < bestDistance)) {
              bestPath = mejorCoche.path;
              bestDistance = mejorDistanciaActual;
              guardarMenteGlobal(bestPath, bestDistance);
            }

            // Guardamos los mejores para referencia de la siguiente carrera
            lastBestCars = coches.slice(0, Math.max(3, Math.floor(coches.length / 4)));
          }
        }
        moverCoches();
      }
      ejecutarGeneracion(0);
    }

    // Solo dibuja la pista al cargar. ¡No inicia ninguna carrera automáticamente!
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawTrack();
  </script>
</body>
</html>
