<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Carrera IA F1</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 0; }
    #controls { margin: 20px; }
    canvas { background: #e0e0e0; display: block; margin: 0 auto; border: 2px solid #444; }
    #autoModeBtn.active, #drawModeBtn.active {
      background: blue;
      color: white;
    }
  </style>
</head>
<body>
  <h2>Carrera IA F1: Entrena tus coches</h2>
  <div id="controls">
    <label for="numCars">Número de IAs: </label>
    <input id="numCars" type="number" min="1" max="50" value="10" style="width: 60px;">
    <button onclick="entrenar()">Correr carrera</button>
    <button onclick="volverHacerCarrera()">Volver a hacer carrera</button>
    <button id="autoModeBtn">Modo Automático</button>
    <button id="drawModeBtn">Modo Dibujo</button>
  </div>
  <canvas id="game" width="800" height="400"></canvas>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const start = { x: 80, y: 200 };
    const goal = { x: 700, y: 320 };
    const numSteps = 90;

    const trackPath = [
      {x: 80, y: 200},
      {x: 200, y: 160},
      {x: 330, y: 120},
      {x: 460, y: 120},
      {x: 580, y: 200},
      {x: 640, y: 260},
      {x: 700, y: 320}
    ];
    const TRACK_WIDTH = 56;

    // ----------- NUEVO: Modo Dibujo -----------
    let drawMode = false;
    let drawing = false;
    let drawPoints = [];
    const drawModeBtn = document.getElementById('drawModeBtn');

    drawModeBtn.addEventListener('click', function() {
      drawMode = !drawMode;
      drawModeBtn.classList.toggle("active", drawMode);
      if(drawMode) {
        drawPoints = [];
        canvas.addEventListener('mousedown', startDraw);
        canvas.addEventListener('mousemove', drawMove);
        canvas.addEventListener('mouseup', endDraw);
      } else {
        canvas.removeEventListener('mousedown', startDraw);
        canvas.removeEventListener('mousemove', drawMove);
        canvas.removeEventListener('mouseup', endDraw);
        drawTrack();
      }
    });

    function startDraw(e) {
      drawing = true;
      drawPoints = [];
      const rect = canvas.getBoundingClientRect();
      drawPoints.push({ x: e.clientX - rect.left, y: e.clientY - rect.top });
    }
    function drawMove(e) {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      drawPoints.push({ x: e.clientX - rect.left, y: e.clientY - rect.top });
      drawTrack();
      // Dibuja la línea sobre la pista
      ctx.beginPath();
      ctx.moveTo(drawPoints[0].x, drawPoints[0].y);
      for (let p of drawPoints) ctx.lineTo(p.x, p.y);
      ctx.strokeStyle = "orange";
      ctx.lineWidth = 3;
      ctx.stroke();
    }
    function endDraw(e) {
      drawing = false;
    }
    // ----------- FIN MODO DIBUJO -----------

    function drawTrack() {
      ctx.save();
      ctx.clearRect(0,0,canvas.width,canvas.height);

      ctx.strokeStyle = "#222";
      ctx.lineWidth = TRACK_WIDTH;
      ctx.beginPath();
      ctx.moveTo(trackPath[0].x, trackPath[0].y);
      for(let i=1; i<trackPath.length; i++){
        ctx.lineTo(trackPath[i].x, trackPath[i].y);
      }
      ctx.stroke();

      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 4;
      ctx.beginPath();
      for(let i=0; i<trackPath.length-1; i++){
        let dx = trackPath[i+1].x-trackPath[i].x;
        let dy = trackPath[i+1].y-trackPath[i].y;
        let len = Math.sqrt(dx*dx+dy*dy);
        let nx = -dy/len, ny = dx/len;
        ctx.moveTo(trackPath[i].x+nx*TRACK_WIDTH/2, trackPath[i].y+ny*TRACK_WIDTH/2);
        ctx.lineTo(trackPath[i+1].x+nx*TRACK_WIDTH/2, trackPath[i+1].y+ny*TRACK_WIDTH/2);
        ctx.moveTo(trackPath[i].x-nx*TRACK_WIDTH/2, trackPath[i].y-ny*TRACK_WIDTH/2);
        ctx.lineTo(trackPath[i+1].x-nx*TRACK_WIDTH/2, trackPath[i+1].y-ny*TRACK_WIDTH/2);
      }
      ctx.stroke();

      ctx.fillStyle = "green";
      ctx.fillRect(goal.x - 12, goal.y - 20, 24, 40);
      ctx.fillStyle = "#fff";
      ctx.fillRect(goal.x - 12, goal.y - 20, 24, 10);
      ctx.fillRect(goal.x - 12, goal.y + 10, 24, 10);

      // ----------- Dibuja línea del usuario si existe -----------
      if (drawPoints.length > 1) {
        ctx.beginPath();
        ctx.moveTo(drawPoints[0].x, drawPoints[0].y);
        for (let p of drawPoints) ctx.lineTo(p.x, p.y);
        ctx.strokeStyle = "orange";
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      // -----------------------------------------------------------
      ctx.restore();
    }

    function carOnTrack(x, y) {
      let minDist = Infinity;
      for(let i=0; i<trackPath.length-1; i++) {
        let ax = trackPath[i].x, ay = trackPath[i].y;
        let bx = trackPath[i+1].x, by = trackPath[i+1].y;
        let dx = bx-ax, dy = by-ay;
        let t = ((x-ax)*dx + (y-ay)*dy) / (dx*dx+dy*dy);
        t = Math.max(0, Math.min(1, t));
        let px = ax + t*dx;
        let py = ay + t*dy;
        let dist = Math.sqrt((x-px)**2 + (y-py)**2);
        if(dist<minDist) minDist = dist;
      }
      return minDist <= TRACK_WIDTH/2 - 5;
    }

    function drawCar(x, y, color, angle = 0) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.fillStyle = color;
      ctx.fillRect(-14, -7, 28, 14);
      ctx.fillStyle = "#222";
      ctx.fillRect(-6, -5, 12, 10);
      ctx.fillStyle = "#555";
      ctx.fillRect(-16, -3, 4, 6);
      ctx.fillRect(12, -3, 6, 6);
      ctx.restore();
    }

    function drawTrail(trail, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.globalAlpha = 0.4;
      ctx.lineWidth = 2;
      ctx.beginPath();
      if (trail.length > 0) {
        ctx.moveTo(trail[0].x, trail[0].y);
        for (let p of trail) ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function distancia(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function randomDirection() {
      const base = 12;
      return [
        { dx: base, dy: 0, da: 0 },
        { dx: base, dy: -4, da: -0.07 },
        { dx: base, dy: 4, da: 0.07 },
        { dx: base, dy: -8, da: -0.12 },
        { dx: base, dy: 8, da: 0.12 }
      ][Math.floor(Math.random() * 5)];
    }

    // Mutación más inteligente (probabilidad menor al principio y final)
    function mutarPath(path) {
      if (!path) return [];
      const total = path.length;
      return path.map((dir, idx) => {
        // Menos probabilidad de mutación en los primeros y últimos 20%
        let prob = 0.1;
        if (idx < total * 0.2 || idx > total * 0.8) prob = 0.03;
        if (Math.random() < prob) {
          return randomDirection();
        }
        return { ...dir };
      });
    }

    // TODOS los coches heredan el mejor path mutado
    function generarCoches(n, heredanDe = null, bestPath = null) {
      let coches = [];
      for (let i = 0; i < n; i++) {
        let coche = {
          pos: { x: start.x, y: start.y },
          angle: 0,
          path: [],
          trail: [{ x: start.x, y: start.y }],
          color: `hsl(${(i * 360) / n}, 80%, 50%)`,
          terminado: false,
          score: 0,
          crashed: false,
          centralidad: 0,
          bonusLinea: 0
        };
        if (bestPath) {
          coche.path = mutarPath(bestPath);
        } else {
          coche.path = [];
        }
        coches.push(coche);
      }
      return coches;
    }

    function guardarMenteGlobal(path, distance) {
      localStorage.setItem("menteGlobalPath", JSON.stringify(path));
      localStorage.setItem("menteGlobalDist", distance);
    }
    function cargarMenteGlobal() {
      return {
        path: JSON.parse(localStorage.getItem("menteGlobalPath") || "null"),
        distance: Number(localStorage.getItem("menteGlobalDist") || "Infinity")
      };
    }
    function borrarMenteGlobal() {
      localStorage.removeItem("menteGlobalPath");
      localStorage.removeItem("menteGlobalDist");
    }

    let lastBestCars = null;

    // Correr carrera - SIEMPRE empieza desde cero pero usa el mejor récord global para comparación
    function entrenar() {
      const n = parseInt(document.getElementById("numCars").value, 10);
      const generaciones = 1; // Solo una generación

      let mente = cargarMenteGlobal();
      let bestPath = mente.path;
      let bestDistance = mente.distance;
      lastBestCars = null;

      function ejecutarGeneracion(gen) {
        let coches = generarCoches(n, null, bestPath);
        let paso = 0;
        let carreraTerminada = false;

        function moverCoches() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawTrack();

          let algunoMoviendo = false;

          for (let car of coches) {
            if (!car.terminado && !car.crashed && paso < numSteps) {
              let dir;
              if (car.path[paso]) {
                dir = car.path[paso];
              } else if (bestPath && Math.random() < 0.7 && bestPath[paso]) {
                dir = bestPath[paso];
              } else {
                dir = randomDirection();
              }
              car.angle += dir.da;
              car.pos.x += dir.dx * Math.cos(car.angle);
              car.pos.y += dir.dx * Math.sin(car.angle) + dir.dy;
              car.path.push({ dx: dir.dx, dy: dir.dy, da: dir.da });
              car.trail.push({ x: car.pos.x, y: car.pos.y });

              // -------------- BONUS CENTRALIDAD --------------
              let minDistToCenter = Infinity;
              for (let i = 0; i < trackPath.length - 1; i++) {
                let ax = trackPath[i].x, ay = trackPath[i].y;
                let bx = trackPath[i+1].x, by = trackPath[i+1].y;
                let dx = bx-ax, dy = by-ay;
                let t = ((car.pos.x-ax)*dx + (car.pos.y-ay)*dy) / (dx*dx+dy*dy);
                t = Math.max(0, Math.min(1, t));
                let px = ax + t*dx;
                let py = ay + t*dy;
                let dist = Math.sqrt((car.pos.x-px)**2 + (car.pos.y-py)**2);
                if (dist < minDistToCenter) minDistToCenter = dist;
              }
              car.centralidad = (car.centralidad || 0) + (TRACK_WIDTH/2 - minDistToCenter);

              // -------------- BONUS SIGUE LÍNEA DIBUJADA --------------
              let bonusLinea = 0;
              if (drawPoints.length > 1) {
                let minDistLinea = Infinity;
                for(let p of drawPoints){
                  let dist = Math.sqrt((car.pos.x - p.x)**2 + (car.pos.y - p.y)**2);
                  if(dist < minDistLinea) minDistLinea = dist;
                }
                if(minDistLinea < 12) bonusLinea = 5; // Puedes ajustar este valor
              }
              car.bonusLinea = (car.bonusLinea || 0) + bonusLinea;

              if (!carOnTrack(car.pos.x, car.pos.y)) {
                car.crashed = true;
                car.terminado = true;
                car.score -= 100;
              }

              if (distancia(car.pos, goal) < 16) car.terminado = true;
              algunoMoviendo = true;
            }
            drawTrail(car.trail, car.color);
            drawCar(car.pos.x, car.pos.y, car.crashed ? "#f00" : car.color, car.angle);
          }

          paso++;
          if (algunoMoviendo && paso <= numSteps) {
            requestAnimationFrame(moverCoches);
          } else if (!carreraTerminada) {
            carreraTerminada = true;

            for (let car of coches) {
              let d = distancia(car.pos, goal);
              if (d < 16) {
                car.score = 1000 - car.trail.length;
              } else {
                car.score = Math.max(0, 500 - d);
              }
              if (car.crashed) car.score -= 100;

              // -------------- SUMA BONUS AL SCORE FINAL --------------
              car.score += (car.centralidad || 0) * 0.05; // Ajusta el multiplicador si quieres
              car.score += (car.bonusLinea || 0);
            }
            coches.sort((a, b) => b.score - a.score);

            for (let i = coches.length - 3; i < coches.length; i++) {
              if (i >= 0) coches[i].score -= 200;
            }

            // Si el mejor coche de esta carrera supera el récord global, lo actualizamos
            let mejorCoche = coches[0];
            let mejorDistanciaActual = distancia(mejorCoche.pos, goal);
            if (mejorCoche.score > 0 && (bestPath === null || mejorDistanciaActual < bestDistance)) {
              bestPath = mejorCoche.path;
              bestDistance = mejorDistanciaActual;
              guardarMenteGlobal(bestPath, bestDistance);
            }
            // Guardamos los mejores para referencia de la siguiente carrera
            lastBestCars = coches.slice(0, Math.max(3, Math.floor(coches.length / 4)));
          }
        }
        moverCoches();
      }
      ejecutarGeneracion(0);
    }

    // Volver a hacer carrera - SIEMPRE usa el récord global para los nuevos coches y solo lo actualiza si es superado
    function volverHacerCarrera(onFinish) {
      const n = parseInt(document.getElementById("numCars").value, 10);

      if (!lastBestCars) {
        alert("Primero corre una carrera para que haya mejores coches de referencia.");
        if (typeof onFinish === 'function') onFinish();
        return;
      }

      let mente = cargarMenteGlobal();
      let bestPath = mente.path;
      let bestDistance = mente.distance;

      function ejecutarGeneracion(gen) {
        let coches = generarCoches(n, lastBestCars, bestPath);
        let paso = 0;
        let carreraTerminada = false;

        function moverCoches() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawTrack();

          let algunoMoviendo = false;

          for (let car of coches) {
            if (!car.terminado && !car.crashed && paso < numSteps) {
              let dir;
              if (car.path[paso]) {
                dir = car.path[paso];
              } else if (bestPath && Math.random() < 0.5 && bestPath[paso]) {
                dir = bestPath[paso];
              } else {
                dir = randomDirection();
              }
              car.angle += dir.da;
              car.pos.x += dir.dx * Math.cos(car.angle);
              car.pos.y += dir.dx * Math.sin(car.angle) + dir.dy;
              car.trail.push({ x: car.pos.x, y: car.pos.y });

              // -------------- BONUS CENTRALIDAD --------------
              let minDistToCenter = Infinity;
              for (let i = 0; i < trackPath.length - 1; i++) {
                let ax = trackPath[i].x, ay = trackPath[i].y;
                let bx = trackPath[i+1].x, by = trackPath[i+1].y;
                let dx = bx-ax, dy = by-ay;
                let t = ((car.pos.x-ax)*dx + (car.pos.y-ay)*dy) / (dx*dx+dy*dy);
                t = Math.max(0, Math.min(1, t));
                let px = ax + t*dx;
                let py = ay + t*dy;
                let dist = Math.sqrt((car.pos.x-px)**2 + (car.pos.y-py)**2);
                if (dist < minDistToCenter) minDistToCenter = dist;
              }
              car.centralidad = (car.centralidad || 0) + (TRACK_WIDTH/2 - minDistToCenter);

              // -------------- BONUS SIGUE LÍNEA DIBUJADA --------------
              let bonusLinea = 0;
              if (drawPoints.length > 1) {
                let minDistLinea = Infinity;
                for(let p of drawPoints){
                  let dist = Math.sqrt((car.pos.x - p.x)**2 + (car.pos.y - p.y)**2);
                  if(dist < minDistLinea) minDistLinea = dist;
                }
                if(minDistLinea < 12) bonusLinea = 5;
              }
              car.bonusLinea = (car.bonusLinea || 0) + bonusLinea;

              if (!carOnTrack(car.pos.x, car.pos.y)) {
                car.crashed = true;
                car.terminado = true;
                car.score -= 100;
              }

              if (distancia(car.pos, goal) < 16) car.terminado = true;
              algunoMoviendo = true;
            }
            drawTrail(car.trail, car.color);
            drawCar(car.pos.x, car.pos.y, car.crashed ? "#f00" : car.color, car.angle);
          }

          paso++;
          if (algunoMoviendo && paso <= numSteps) {
            requestAnimationFrame(moverCoches);
          } else if (!carreraTerminada) {
            carreraTerminada = true;

            for (let car of coches) {
              let d = distancia(car.pos, goal);
              if (d < 16) {
                car.score = 1000 - car.trail.length;
              } else {
                car.score = Math.max(0, 500 - d);
              }
              if (car.crashed) car.score -= 100;

              // -------------- SUMA BONUS AL SCORE FINAL --------------
              car.score += (car.centralidad || 0) * 0.05;
              car.score += (car.bonusLinea || 0);
            }
            coches.sort((a, b) => b.score - a.score);

            for (let i = coches.length - 3; i < coches.length; i++) {
              if (i >= 0) coches[i].score -= 200;
            }

            // Si el mejor coche de esta carrera supera el récord global, lo actualizamos
            let mejorCoche = coches[0];
            let mejorDistanciaActual = distancia(mejorCoche.pos, goal);
            if (mejorCoche.score > 0 && (bestPath === null || mejorDistanciaActual < bestDistance)) {
              bestPath = mejorCoche.path;
              bestDistance = mejorDistanciaActual;
              guardarMenteGlobal(bestPath, bestDistance);
            }

            // Guardamos los mejores para referencia de la siguiente carrera
            lastBestCars = coches.slice(0, Math.max(3, Math.floor(coches.length / 4)));

            if (typeof onFinish === 'function') onFinish();
          }
        }
        moverCoches();
      }
      ejecutarGeneracion(0);
    }

    // Modo automático
    let autoMode = false;
    let autoModeTimeout = null;
    const autoModeBtn = document.getElementById('autoModeBtn');
    autoModeBtn.addEventListener('click', function() {
      autoMode = !autoMode;
      if (autoMode) {
        autoModeBtn.classList.add("active");
        startAutoMode();
      } else {
        autoModeBtn.classList.remove("active");
        if (autoModeTimeout) clearTimeout(autoModeTimeout);
      }
    });

    function startAutoMode() {
      if (!autoMode) return;
      volverHacerCarrera(() => {
        autoModeTimeout = setTimeout(startAutoMode, 200); // puedes ajustar el tiempo aquí (ms)
      });
    }

    // Solo dibuja la pista al cargar. ¡No inicia ninguna carrera automáticamente!
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawTrack();
  </script>
</body>
</html>
