<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Carrera IA F1 - IA con Sensores</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 0; }
    #controls { margin: 20px; }
    canvas { background: #e0e0e0; display: block; margin: 0 auto; border: 2px solid #444; }
    #autoModeBtn.active {
      background: blue;
      color: white;
    }
  </style>
  <!-- Synaptic.js para redes neuronales -->
  <script src="https://cdn.jsdelivr.net/npm/synaptic@1.1.4/dist/synaptic.min.js"></script>
</head>
<body>
  <h2>Carrera IA F1: IA con Sensores Evolutivos</h2>
  <div id="controls">
    <label for="numCars">Número de IAs: </label>
    <input id="numCars" type="number" min="1" max="50" value="12" style="width: 60px;">
    <button onclick="iniciarCarrera()">Iniciar carrera</button>
    <button id="autoModeBtn">Modo Automático</button>
    <span id="genInfo"></span>
  </div>
  <canvas id="game" width="800" height="400"></canvas>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const start = { x: 80, y: 200 };
    const goal = { x: 700, y: 320 };
    const numSteps = 90;
    const trackPath = [
      {x: 80, y: 200},
      {x: 200, y: 160},
      {x: 330, y: 120},
      {x: 460, y: 120},
      {x: 580, y: 200},
      {x: 640, y: 260},
      {x: 700, y: 320}
    ];
    const TRACK_WIDTH = 56;

    // ----- SENSORES -----
    function sensorDistanciaBorde(x, y, angle, step = 3, maxDist = 60) {
      for (let d = 0; d < maxDist; d += step) {
        let px = x + Math.cos(angle) * d;
        let py = y + Math.sin(angle) * d;
        if (!carOnTrack(px, py)) return d / maxDist;
      }
      return 1;
    }

    // Red Neuronal: entradas = dx, dy, anguloRelativo, sensorIzq, sensorDer; salidas = giro, aceleracion
    function crearRedNeuronal() {
      return new synaptic.Architect.Perceptron(5, 8, 2);
    }

    function mutarRed(red, tasa = 0.1, prob = 0.1) {
      red.layers.input.list.concat(red.layers.hidden[0].list, red.layers.output.list).forEach(n => {
        Object.values(n.connections.projected).forEach(conn => {
          if (Math.random() < prob) {
            conn.weight += (Math.random() - 0.5) * tasa;
          }
        });
      });
    }

    function clonarRed(red) {
      return synaptic.Network.fromJSON(red.toJSON());
    }

    function crearCoche(color) {
      return {
        pos: { x: start.x, y: start.y },
        angle: 0,
        trail: [{ x: start.x, y: start.y }],
        color,
        terminado: false,
        crashed: false,
        score: 0,
        red: crearRedNeuronal()
      };
    }

    function drawTrack() {
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#222";
      ctx.lineWidth = TRACK_WIDTH;
      ctx.beginPath();
      ctx.moveTo(trackPath[0].x, trackPath[0].y);
      for(let i=1; i<trackPath.length; i++){
        ctx.lineTo(trackPath[i].x, trackPath[i].y);
      }
      ctx.stroke();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 4;
      ctx.beginPath();
      for(let i=0; i<trackPath.length-1; i++){
        let dx = trackPath[i+1].x-trackPath[i].x;
        let dy = trackPath[i+1].y-trackPath[i].y;
        let len = Math.sqrt(dx*dx+dy*dy);
        let nx = -dy/len, ny = dx/len;
        ctx.moveTo(trackPath[i].x+nx*TRACK_WIDTH/2, trackPath[i].y+ny*TRACK_WIDTH/2);
        ctx.lineTo(trackPath[i+1].x+nx*TRACK_WIDTH/2, trackPath[i+1].y+ny*TRACK_WIDTH/2);
        ctx.moveTo(trackPath[i].x-nx*TRACK_WIDTH/2, trackPath[i].y-ny*TRACK_WIDTH/2);
        ctx.lineTo(trackPath[i+1].x-nx*TRACK_WIDTH/2, trackPath[i+1].y-ny*TRACK_WIDTH/2);
      }
      ctx.stroke();
      ctx.fillStyle = "green";
      ctx.fillRect(goal.x - 12, goal.y - 20, 24, 40);
      ctx.fillStyle = "#fff";
      ctx.fillRect(goal.x - 12, goal.y - 20, 24, 10);
      ctx.fillRect(goal.x - 12, goal.y + 10, 24, 10);
      ctx.restore();
    }

    function carOnTrack(x, y) {
      let minDist = Infinity;
      for(let i=0; i<trackPath.length-1; i++) {
        let ax = trackPath[i].x, ay = trackPath[i].y;
        let bx = trackPath[i+1].x, by = trackPath[i+1].y;
        let dx = bx-ax, dy = by-ay;
        let t = ((x-ax)*dx + (y-ay)*dy) / (dx*dx+dy*dy);
        t = Math.max(0, Math.min(1, t));
        let px = ax + t*dx;
        let py = ay + t*dy;
        let dist = Math.sqrt((x-px)**2 + (y-py)**2);
        if(dist<minDist) minDist = dist;
      }
      return minDist <= TRACK_WIDTH/2 - 5;
    }

    function drawCar(x, y, color, angle = 0) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      ctx.fillStyle = color;
      ctx.fillRect(-14, -7, 28, 14);
      ctx.fillStyle = "#222";
      ctx.fillRect(-6, -5, 12, 10);
      ctx.fillStyle = "#555";
      ctx.fillRect(-16, -3, 4, 6);
      ctx.fillRect(12, -3, 6, 6);
      ctx.restore();
    }

    function drawTrail(trail, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.globalAlpha = 0.4;
      ctx.lineWidth = 2;
      ctx.beginPath();
      if (trail.length > 0) {
        ctx.moveTo(trail[0].x, trail[0].y);
        for (let p of trail) ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    function distancia(a, b) {
      return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    // --- Algoritmo evolutivo con sensores extras ---
    let coches = [];
    let generacion = 1;
    let mejoresRedes = [];
    let numMejores = 8;
    let mejorHist = null; // Elitismo permanente

    function iniciarCarrera() {
      const n = parseInt(document.getElementById("numCars").value, 10);
      let colores = [];
      for (let i = 0; i < n; i++)
        colores.push(`hsl(${(i * 360) / n}, 80%, 50%)`);
      coches = [];
      for (let i = 0; i < n; i++) {
        let coche = crearCoche(colores[i]);
        if (mejoresRedes.length > 0) {
          let base = clonarRed(mejoresRedes[Math.floor(Math.random()*mejoresRedes.length)]);
          mutarRed(base, 0.1, 0.1); // Tasa de mutación menor
          coche.red = base;
        } else {
          // Variación inicial si es la primera generación
          mutarRed(coche.red, 0.3, 0.3);
        }
        coches.push(coche);
      }
      // Añade siempre la mejor red histórica (elitismo permanente)
      if (mejorHist) {
        coches[0].red = clonarRed(mejorHist);
      }
      document.getElementById("genInfo").textContent = `Generación: ${generacion}`;
      correrCarrera();
    }

    function correrCarrera() {
      let paso = 0;
      let carreraActiva = true;
      function mover() {
        drawTrack();
        let algunoMoviendo = false;
        for (let car of coches) {
          if (!car.terminado && !car.crashed && paso < numSteps) {
            let dx = goal.x - car.pos.x;
            let dy = goal.y - car.pos.y;
            let angleToGoal = Math.atan2(dy, dx);
            let angleDiff = angleToGoal - car.angle;
            while (angleDiff > Math.PI) angleDiff -= 2*Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2*Math.PI;
            let sensorIzq = sensorDistanciaBorde(car.pos.x, car.pos.y, car.angle - Math.PI/2);
            let sensorDer = sensorDistanciaBorde(car.pos.x, car.pos.y, car.angle + Math.PI/2);
            let input = [
              dx / canvas.width,
              dy / canvas.height,
              angleDiff / Math.PI,
              sensorIzq,
              sensorDer
            ];
            let [giro, aceleracion] = car.red.activate(input);
            if (giro < 0.45) car.angle -= 0.07;
            else if (giro > 0.55) car.angle += 0.07;
            if (aceleracion > 0.5) {
              car.pos.x += 10 * Math.cos(car.angle);
              car.pos.y += 10 * Math.sin(car.angle);
            }
            car.trail.push({ x: car.pos.x, y: car.pos.y });
            if (!carOnTrack(car.pos.x, car.pos.y)) {
              car.crashed = true;
              car.terminado = true;
              car.score -= 100;
            }
            if (distancia(car.pos, goal) < 16) {
              car.terminado = true;
              car.score += 1000 - car.trail.length;
            }
            algunoMoviendo = true;
          }
          drawTrail(car.trail, car.color);
          drawCar(car.pos.x, car.pos.y, car.crashed ? "#f00" : car.color, car.angle);
        }
        paso++;
        if (algunoMoviendo && paso <= numSteps) {
          requestAnimationFrame(mover);
        } else if (carreraActiva) {
          carreraActiva = false;
          evaluarYPrepararSiguienteGen();
        }
      }
      mover();
    }

    function evaluarYPrepararSiguienteGen() {
      for (let car of coches) {
        let d = distancia(car.pos, goal);
        // Score: recompensa más si se acerca a la meta, menos penalización por choque
        car.score += Math.max(0, 700 - d * 1.3);
        if (car.crashed) car.score -= 70;
      }
      coches.sort((a, b) => b.score - a.score);
      mejoresRedes = [];
      for (let i = 0; i < numMejores && i < coches.length; i++) {
        mejoresRedes.push(clonarRed(coches[i].red));
      }
      // Guarda la mejor red histórica
      if (!mejorHist || coches[0].score > mejorHist.score) {
        mejorHist = clonarRed(coches[0].red);
        mejorHist.score = coches[0].score;
      }
      generacion++;
      if (autoMode) {
        setTimeout(() => iniciarCarrera(), 300);
      }
    }

    // --- Modo automático ---
    let autoMode = false;
    const autoModeBtn = document.getElementById('autoModeBtn');
    autoModeBtn.addEventListener('click', function() {
      autoMode = !autoMode;
      if (autoMode) {
        autoModeBtn.classList.add("active");
        iniciarCarrera();
      } else {
        autoModeBtn.classList.remove("active");
      }
    });

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawTrack();
  </script>
</body>
</html>
