<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Carrera IA F1 - 3D</title>
  <style>
    body { margin: 0; background: #222; color: #fff; }
    #ui {
      position: absolute; top: 18px; left: 18px; z-index: 10;
      background: rgba(20,20,20,0.7); padding: 16px; border-radius: 8px;
    }
    button { font-size: 1em; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.151.3/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/synaptic@1.1.4/dist/synaptic.min.js"></script>
</head>
<body>
  <div id="ui">
    <button onclick="startRace()">Iniciar carrera</button>
    <span id="genInfo"></span>
  </div>
  <script>
    // --- Parámetros ---
    const NUM_CARS = 20;
    const NUM_GEN = 4; // coches que pasan a la siguiente generación
    const MUT_RATE = 0.25;
    const TRACK_LEN = 400;
    const CAR_SIZE = { x: 4, y: 2, z: 8 };
    const MAX_SPEED = 3;
    const STEER_ANGLE = 0.04;
    const NUM_SENSORS = 3;

    // --- Three.js setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Luz
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(100,200,100);
    scene.add(dirLight);

    // Pista (recta y curva simple)
    const trackShape = [
      new THREE.Vector3(0, 0, 160),
      new THREE.Vector3(0, 0, 80),
      new THREE.Vector3(40, 0, 0),
      new THREE.Vector3(100, 0, -60),
      new THREE.Vector3(180, 0, -80),
      new THREE.Vector3(250, 0, -40),
      new THREE.Vector3(280, 0, 40),
      new THREE.Vector3(260, 0, 120),
      new THREE.Vector3(180, 0, 180),
      new THREE.Vector3(100, 0, 200),
      new THREE.Vector3(0, 0, 160)
    ];

    // Dibujar pista (tubo)
    const curve = new THREE.CatmullRomCurve3(trackShape, true);
    const tubeGeometry = new THREE.TubeGeometry(curve, 150, 12, 16, true);
    const tubeMaterial = new THREE.MeshPhongMaterial({ color: 0x2222aa, opacity:0.7, transparent:true });
    const trackMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
    scene.add(trackMesh);

    // Meta
    const goalGeo = new THREE.BoxGeometry(24,2,24);
    const goalMat = new THREE.MeshPhongMaterial({color:0x00ff00});
    const goalMesh = new THREE.Mesh(goalGeo, goalMat);
    goalMesh.position.copy(trackShape[0]);
    goalMesh.position.y += 2;
    scene.add(goalMesh);

    // --- IA y coches ---
    function crearRed() {
      // Entradas: sensor izq, sensor centro, sensor der, speed, angulo a meta, distancia a meta
      return new synaptic.Architect.Perceptron(NUM_SENSORS+3, 8, 2);
    }
    function mutarRed(red, tasa = MUT_RATE, prob = MUT_RATE) {
      red.layers.input.list.concat(red.layers.hidden[0].list, red.layers.output.list).forEach(n => {
        Object.values(n.connections.projected).forEach(conn => {
          if (Math.random() < prob) conn.weight += (Math.random() - 0.5) * tasa;
        });
      });
    }
    function clonarRed(red) {
      return synaptic.Network.fromJSON(red.toJSON());
    }

    function createCar(colorHex = 0xff0000) {
      const geo = new THREE.BoxGeometry(CAR_SIZE.x, CAR_SIZE.y, CAR_SIZE.z);
      const mat = new THREE.MeshPhongMaterial({color: colorHex});
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);
      return mesh;
    }

    // --- Estado global ---
    let cars = [];
    let brains = [];
    let velocities = [];
    let angles = [];
    let scores = [];
    let finished = [];
    let gen = 1;
    let bestBrains = [];

    // --- Sensores (raycast) ---
    function getSensors(pos, angle) {
      // Tres sensores: izq, centro, der
      const sensorAngles = [-Math.PI/4, 0, Math.PI/4];
      let res = [];
      for (let i=0; i<sensorAngles.length; ++i) {
        const dir = new THREE.Vector3(
          Math.sin(angle + sensorAngles[i]),
          0,
          Math.cos(angle + sensorAngles[i])
        );
        const ray = new THREE.Raycaster(pos.clone(), dir, 0, 30);
        const intersects = ray.intersectObject(trackMesh, true);
        if (intersects.length === 0) res.push(1); // No colisión => lejos
        else res.push(intersects[0].distance / 30); // Normalizado
      }
      return res;
    }

    // --- Inicializar generación ---
    function startRace() {
      // Eliminar coches viejos
      for (let c of cars) scene.remove(c);
      cars = [];
      brains = [];
      velocities = [];
      angles = [];
      scores = [];
      finished = [];

      // Crear coches nuevos
      for (let i=0; i<NUM_CARS; ++i) {
        const color = new THREE.Color().setHSL(i/NUM_CARS, 0.7, 0.55).getHex();
        cars.push(createCar(color));
        if (bestBrains.length) {
          let base = clonarRed(bestBrains[Math.floor(Math.random()*bestBrains.length)]);
          mutarRed(base);
          brains.push(base);
        } else {
          brains.push(crearRed());
        }
        velocities.push(0.8 + Math.random()*0.2); // arranque suave
        angles.push(Math.PI/2);
        scores.push(0);
        finished.push(false);
        // Posición de arranque
        cars[i].position.copy(trackShape[0]);
        cars[i].rotation.y = 0;
      }
      if (bestBrains.length) {
        brains[0] = clonarRed(bestBrains[0]); // El mejor va igual
      }
      gen++;
      document.getElementById('genInfo').textContent = 'Generación: ' + gen;
      animateRace();
    }

    // --- Animación y lógica IA ---
    let stepCount = 0;
    function animateRace() {
      stepCount = 0;
      function step() {
        let anyRunning = false;
        for (let i=0; i<cars.length; ++i) {
          if (finished[i]) continue;
          // Sensores
          const pos = cars[i].position;
          const angle = angles[i];

          // Distancia y ángulo a meta
          const goal = trackShape[0];
          const vecToGoal = new THREE.Vector3().subVectors(goal, pos);
          const distGoal = vecToGoal.length()/200; // Normalizado
          const angGoal = Math.atan2(vecToGoal.x, vecToGoal.z) - angle;

          // Sensores
          const sensors = getSensors(pos, angle);

          // Inputs a la red
          const input = [
            ...sensors,
            velocities[i]/MAX_SPEED,
            Math.sin(angGoal),
            distGoal
          ];
          let [steer, accel] = brains[i].activate(input);

          // Actualizar dirección y velocidad
          if (steer < 0.45) angles[i] -= STEER_ANGLE;
          else if (steer > 0.55) angles[i] += STEER_ANGLE;
          velocities[i] += (accel-0.5)*0.15;
          velocities[i] = Math.max(0, Math.min(MAX_SPEED, velocities[i]));

          // Mover coche
          cars[i].rotation.y = -angles[i];
          cars[i].position.x += velocities[i]*Math.sin(angles[i]);
          cars[i].position.z += velocities[i]*Math.cos(angles[i]);

          // Puntos por acercarse a meta
          scores[i] = 1000 - pos.distanceTo(goal);

          // Terminar si llega a meta
          if (pos.distanceTo(goal) < 12) {
            finished[i] = true;
            scores[i] += 10000;
          }

          // Limitar pista: si se sale, termina
          if (!isOnTrack(pos)) {
            finished[i] = true;
            scores[i] -= 300;
          }

          // Si sigue en carrera
          if (!finished[i]) anyRunning = true;
        }
        renderer.render(scene, camera);

        // Cámara sigue al mejor coche
        const bestIdx = scores.indexOf(Math.max(...scores));
        camera.position.lerp(new THREE.Vector3(
          cars[bestIdx].position.x + 40,
          55,
          cars[bestIdx].position.z + 60
        ), 0.08);
        camera.lookAt(cars[bestIdx].position.x, 4, cars[bestIdx].position.z);

        stepCount++;
        if (anyRunning && stepCount < 850) requestAnimationFrame(step);
        else nextGeneration();
      }
      step();
    }

    // --- Chequeo si está en pista ---
    function isOnTrack(pos) {
      // Simple: cerca del tubo
      let minDist = Infinity;
      for (let t=0; t<=1; t+=0.02) {
        const p = curve.getPoint(t);
        const dist = pos.distanceTo(p);
        if (dist<minDist) minDist = dist;
      }
      return minDist <= 14;
    }

    // --- Evolución: selecciona los mejores y repite ---
    function nextGeneration() {
      // Selecciona los mejores
      let idx = Array.from(Array(cars.length).keys());
      idx.sort((a,b)=>scores[b]-scores[a]);
      bestBrains = [];
      for (let i=0; i<NUM_GEN; ++i) bestBrains.push(clonarRed(brains[idx[i]]));
      // Siguiente generación en 2s
      setTimeout(startRace, 1200);
    }

    // --- Inicialización ---
    camera.position.set(0, 76, 210);
    camera.lookAt(0,0,0);
    startRace();
  </script>
</body>
</html>
